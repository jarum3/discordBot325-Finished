// TODO docs
/**
 * Handles a stringSelectMenu with CustomId 'course-remove',
 * removing an entered course from the list of roles,
 * deleting its associated active server role,
 * and deleting its associated veteran role if no members exist with it.
 * # Command
 * * This menu is generated by the {@link commands/removeoptrole | Remove opt role command}
 * @packageDocumentation
 */
import { Events, BaseInteraction, GuildBasedChannel, CategoryChannel, GuildMember } from 'discord.js';
import { getListFromFile, getSemester, saveListToFile } from '../../helpers/functions';
import { CourseRole } from '../../helpers/role';

module.exports = {
  name: Events.InteractionCreate,
  async execute(interaction: BaseInteraction) {
    // Move course into bottom physically, remove from course list, move students into veteran roles, save that data into file
    if (!interaction.isStringSelectMenu()) return;
    if (!(interaction.customId === 'archive-course')) return;
    if (!(interaction.guild)) return;
    await interaction.deferUpdate();
    let rolesList = getListFromFile('data/courses.json') as CourseRole[];
    const rolesSelected = interaction.values;
    const archivedRoles: string[] = [];
    // Assign roles in a loop, in case we want to make this a multi-select later.
    for (const selectedElement of rolesSelected) {
      for (const course of rolesList) {
        if (course.name != selectedElement) continue;
        const courseRole = course.role;
        const veteranRole = course.veteranRole;
        const serverRole = await interaction.guild.roles.fetch(courseRole.id);
        const serverVeteranRole = await interaction.guild.roles.fetch(veteranRole.id);
        // TODO Dropdown for confirmation
        if (course.category) {
          const category = await interaction.guild.channels.fetch(course.category.id) as CategoryChannel;
          if (category) {
            const channels: CategoryChannel[] = [];
            for (const channelArray of interaction.guild.channels.cache.entries()) {
              for (const possibleChannel of channelArray) {
                if ((<GuildBasedChannel>possibleChannel).name !== undefined) {
                  const channel = possibleChannel as GuildBasedChannel;
                  if ((<CategoryChannel>channel).children !== undefined) {
                    channels.push(channel as CategoryChannel);
                  }
                }
              }
            }
            channels.sort((a, b) => a.position - b.position);
            // channels now represents all the categories in the server, sorted by their position
            let foundCurrent = false;
            let position = -1;
            for (const channel of channels) {
              if (channel.name.includes(getSemester())) foundCurrent = true;
              if (foundCurrent === true && !channel.name.includes(getSemester())) {
                position = channel.position - 1;
                break;
              }
            }
            if (position >= 0) category.setPosition(position);
            else category.setPosition(300000);
            if (serverRole) {
              const permissions = category.permissionsFor(serverRole).serialize();
              category.permissionOverwrites.delete(serverRole);
              if (serverVeteranRole) category.permissionOverwrites.create(serverVeteranRole, permissions);
            }
            // Category = current category
            // ServerRole = Course Role
            // ServerVeteranRole = Veteran Role
            // Find students with current student role
            const students: GuildMember[] = [];
            for (const studentsArray of interaction.guild.members.cache.entries()) {
              for (const possibleStudent of studentsArray) {
                const student = possibleStudent as GuildMember;
                if ((<GuildMember>student).roles !== undefined) students.push(student as GuildMember);
              }
            }
            for (const student of students) {
              if (serverRole && serverVeteranRole) {
                student.roles.remove(serverRole);
                student.roles.add(serverVeteranRole);
              }
            }
            const index = rolesList.indexOf(course);
            rolesList = rolesList.splice(index, 1);
            const prevRolesList = getListFromFile('data/prevsemester.json') as CourseRole[];
            const oldCourse = new CourseRole({
              prefix: course.prefix,
              number: course.number,
              role: course.role,
              veteranRole: course.veteranRole,
              video: course.video,
              jointClass: course.jointClass,
              name: course.name,
            });
            prevRolesList.push(oldCourse);
            saveListToFile(rolesList, 'data/courses.json');
            saveListToFile(prevRolesList, 'data/prevsemester.json');
          }
        }
        else {
          await interaction.reply('This course doesn\'t currently have a category');
        }
      }
    }
    await interaction.editReply({ content: 'Course archived: ' + archivedRoles.join(', '), components: [] });
  },
};